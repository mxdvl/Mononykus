import * as esbuild from "https://deno.land/x/esbuild@v0.17.16/mod.js";
import sveltePlugin from "https://esm.sh/v115/esbuild-svelte@0.7.3";
import { get_svelte_internal, internal } from "./plugins.ts";
import { walk } from "https://deno.land/std@0.177.0/fs/walk.ts";
import { globToRegExp } from "https://deno.land/std@0.177.0/path/glob.ts";
import { ensureDir } from "https://deno.land/std@0.177.0/fs/ensure_dir.ts";
import { parse } from "https://deno.land/std@0.177.0/flags/mod.ts";
import { green } from "https://deno.land/std@0.177.0/fmt/colors.ts";
import { exists } from "https://deno.land/std@0.183.0/fs/exists.ts";
import { pathToFileURL } from "https://deno.land/std@0.177.0/node/url.ts";
import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { create_handler } from "./server.ts";
import { normalize } from "https://deno.land/std@0.177.0/path/mod.ts";

const flags = parse(Deno.args, {
	string: ["site", "build", "base"],
	boolean: ["dev"],
	default: { site: "_site/", dev: false },
});

const site_dir = flags.site.replace(/\/?$/, "/");
const build_dir = (flags.build ?? `${site_dir}build/`).replace(/\/?$/, "/");
const current_working_directory = pathToFileURL(Deno.cwd());

// clean out old builds, if they exist
try {
	await Deno.remove(build_dir, { recursive: true });
} catch (_error) {
	// do nothing
}

export const get_svelte_files = async ({
	dir,
	islands = false,
}: {
	dir: "routes/" | "components/";
	islands?: boolean;
}) => {
	const files = [];
	for await (const { name, isFile } of Deno.readDir(site_dir + dir)) {
		if (islands) {
			if (isFile && name.endsWith(".island.svelte")) {
				files.push(site_dir + dir + name);
			}
		} else {
			if (
				isFile &&
				name.endsWith(".svelte") &&
				!name.endsWith(".island.svelte")
			) {
				files.push(site_dir + dir + name);
			}
		}
	}
	return files;
};

const configs = {
	logLevel: "info",
	format: "esm",
	minify: true,
} as const satisfies Partial<esbuild.BuildOptions>;

await ensureDir(build_dir);

const svelte_islands = await get_svelte_files({
	dir: "components/",
	islands: true,
});

const create_island_component = async (islands: string[]) => {
	const island_names = islands
		.map((island) => island.split("/").at(-1)?.replace(".island.svelte", ""))
		.filter(Boolean);

	const Island = `
<!-- auto-generated by the build script -->

<script>
${
		island_names
			.map(
				(island) =>
					`import ${island} from "../components/${island}.island.svelte";`,
			)
			.join("\n")
	}

/** @type {Record<string, unknown>} */
export let props = {};

	const islands = /** @type {const} */ ({ ${island_names.join(",")} });

	/** @type {keyof typeof islands} */
	export let name;
</script>

<one-claw {name} props={JSON.stringify(props)}>
<svelte:component this={islands[name]} {...props} />
</one-claw>
		`;

	await Deno.writeTextFile(
		build_dir + "Island.svelte",
		Island,
	);
};

const internal_filepath = build_dir + "internal.js";
await create_island_component(svelte_islands);
await get_svelte_internal(internal_filepath);

const server: esbuild.BuildOptions = {
	entryPoints: [
		await get_svelte_files({ dir: "routes/" }),
		await get_svelte_files({ dir: "components/" }),
	]
		.flat(),
	outdir: build_dir,
	bundle: true,
	plugins: [
		// @ts-expect-error -- there’s an issue with ImportKind
		sveltePlugin({
			compilerOptions: { generate: "ssr", hydratable: true },
		}),
		internal(internal_filepath),
	],
	...configs,
};

const client: esbuild.BuildOptions = {
	entryPoints: svelte_islands,
	outdir: build_dir + "components/",
	bundle: true,
	plugins: [
		// @ts-expect-error -- there’s an issue with ImportKind
		sveltePlugin({
			compilerOptions: { generate: "dom", hydratable: true },
		}),
		internal(internal_filepath),
	],
	...configs,
};

const copy_assets = async () => {
	for await (const { name } of Deno.readDir(site_dir + "assets")) {
		await Deno.copyFile(site_dir + "assets/" + name, build_dir + name);
	}
};

for (const required_file of ["template.html", "islands.js"]) {
	if (!(await exists(site_dir + required_file))) {
		const content = await fetch(
			"https://deno.land/x/mononykus@0.2.1/src/" + required_file,
		).then((r) => r.text());
		await Deno.writeTextFile(site_dir + required_file, content);
	}
}

const template = await Deno.readTextFile(site_dir + "template.html");
const islands = await Deno.readTextFile(site_dir + "islands.js")
	.then((contents) =>
		flags.base
			? contents.replace(
				"import(`/components/",
				"import(`" + normalize(`/${flags.base}/components/`),
			)
			: contents
	);
const inline_styles = await Deno.readTextFile(
	site_dir + "assets" + "/inline.css",
).catch(() => "");

const generate_route = async (route: string) => {
	const {
		html,
		css: { code: css },
	} = (await import(
		current_working_directory + "/" + build_dir + "routes/" + route + ".js"
	))
		.default
		.render();

	const output = template
		.replace(
			"<!-- Svelte:css -->",
			`<style>${inline_styles}</style><style>${css}</style>`,
		)
		.replace(
			"<!-- Svelte:islands -->",
			`<script type="module">${islands}</script>`,
		)
		.replace("<!-- Svelte:html -->", html);

	const filename = build_dir + route + ".html";
	await Deno.writeTextFile(filename, output);
	console.info(" ", filename);
};

const generate_routes = async () => {
	const start = performance.now();
	console.log("");
	for await (
		const { isFile, path } of walk(site_dir, {
			match: [globToRegExp(`${site_dir}routes/**/*.svelte`)],
		})
	) {
		if (!isFile) continue;
		const route = path.replace(site_dir + "routes/", "").replace(".svelte", "");

		await generate_route(route);
	}

	console.info(
		"\n◎ ",
		green(`Generated routes in ${Math.ceil(performance.now() - start)}ms`),
	);
};

await esbuild.build(server);
await esbuild.build(client);
await copy_assets();
await generate_routes();

if (flags.dev) {
	const watcher = Deno.watchFs(site_dir);
	await esbuild.context(server).then(({ watch }) => watch());
	await esbuild.context(client).then(({ watch }) => watch());
	serve(create_handler({ base: flags.base, build_dir }), { port: 4507 });
	for await (const { kind, paths: [path] } of watcher) {
		if (path && (kind === "modify" || kind === "create")) {
			if (path.includes(build_dir)) continue;
			console.log({ path, site_dir });
			if (path.includes(site_dir + "assets/")) {
				await Deno.copyFile(
					path,
					path.replace("/_site/assets/", "/_site/build/"),
				);
			} else if (path.includes(site_dir + "routes/")) {
				console.log(path);
			}
		}
	}
} else {
	esbuild.stop();
}
